# Real-Time Voice Transcription & Classifier Configuration

# Audio Capture Settings
audio:
  sample_rate: 16000          # 16kHz for Whisper compatibility
  channels: 1                  # Mono audio
  chunk_duration: 1.5          # Seconds per audio chunk
  buffer_duration: 30          # Maximum buffer duration in seconds
  device: null                 # null = default microphone, or specify device index
  vad_aggressiveness: 2        # Voice Activity Detection: 0-3 (higher = more aggressive)
  silence_threshold: 0.5       # Seconds of silence before considering utterance complete
  min_speech_duration: 0.3     # Minimum speech duration to process (seconds)

# Whisper Transcription Settings
transcription:
  model_size: "medium"         # Options: tiny, base, small, medium, large-v2, large-v3
                               # medium = better accuracy, ~2GB RAM, ~200-400ms latency
  device: "auto"               # Options: auto, cpu, cuda
  compute_type: "int8"         # Options: int8, float16, float32 (int8 for speed)
  language: "en"               # Language code or null for auto-detect
  beam_size: 5                 # Beam search size (5 = good balance of speed/accuracy)
  best_of: 5                   # Number of candidates (5 = better accuracy)
  temperature: [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]  # Multiple temperatures for fallback
  vad_filter: true             # Use Whisper's built-in VAD filter
  word_timestamps: false       # Disable for lower latency
  condition_on_previous_text: true  # Use context from previous utterances
  compression_ratio_threshold: 2.4  # Detect and skip low-quality audio
  log_prob_threshold: -1.0     # Skip segments with low confidence
  no_speech_threshold: 0.6     # Skip if likely no speech

# Text Cleanup Settings
text_cleanup:
  remove_filler_words: true
  filler_words:
    - "um"
    - "umm"
    - "uh"
    - "uhh"
    - "ah"
    - "ahh"
    - "er"
    - "err"
    - "like"
    - "you know"
    - "i mean"
    - "sort of"
    - "kind of"
    - "basically"
  normalize_case: true         # Convert to lowercase for classification
  strip_punctuation: false     # Keep punctuation for context

# Classification Settings
classification:
  default_class: "NON-CODING"  # Default when ambiguous
  confidence_threshold: 0.7    # Minimum confidence for CODING classification
  
  # Coding intent verbs (must be present for CODING classification)
  coding_verbs:
    - "write"
    - "implement"
    - "create"
    - "build"
    - "generate"
    - "code"
    - "program"
    - "develop"
    - "make"
    - "design"
    - "solve"
    - "fix"
    - "debug"
    - "complete"
    - "finish"
    - "find"
    - "give"
    - "show"
    - "provide"
    - "return"
  
  # Coding intent phrases (strong indicators)
  coding_phrases:
    # Direct code requests
    - "write code"
    - "write a function"
    - "write a program"
    - "write a script"
    - "implement a"
    - "implement the"
    - "create a function"
    - "create a class"
    - "create an api"
    - "build a"
    - "generate code"
    - "code for"
    - "code to"
    - "program to"
    - "program for"
    - "give me code"
    - "show me code"
    - "write me"
    - "can you code"
    - "can you write"
    
    # Problem solving phrases
    - "solve this"
    - "solve the"
    - "solve a"
    - "find the solution"
    - "find a solution"
    - "find an algorithm"
    - "find the code"
    - "give me"
    - "give the"
    - "show me"
    - "show the"
    - "provide code"
    - "provide solution"
    - "provide the code"
    - "return the code"
    - "return code"
    
    # Coding platforms
    - "coding question"
    - "coding problem"
    - "coding challenge"
    - "algorithm problem"
    - "algorithm question"
    - "dsa question"
    - "dsa problem"
    - "leetcode"
    - "hackerrank"
    - "codeforces"
    - "codechef"
    - "atcoder"
    - "topcoder"
    
    # Algorithm approaches
    - "traversal of"
    - "traversal for"
    - "preorder traversal"
    - "inorder traversal"
    - "postorder traversal"
    - "level order traversal"
    - "bfs approach"
    - "dfs approach"
    - "bfs of"
    - "dfs of"
    - "bfs for"
    - "dfs for"
    - "dijkstra algorithm"
    - "dijkstra for"
    - "shortest path algorithm"
    - "shortest path for"
    - "longest path algorithm"
    - "longest path for"
    - "minimum spanning tree"
    - "topological sort algorithm"
    - "topological sort for"
    - "binary search for"
    - "binary search in"
    - "linear search for"
    - "merge sort for"
    - "merge sort in"
    - "quick sort for"
    - "quick sort in"
    - "heap sort for"
    - "bubble sort for"
    
    # Data structure operations
    - "insertion in"
    - "deletion from"
    - "search in"
    - "insert into"
    - "delete from"
    - "remove from"
    - "add to"
    - "push to"
    - "pop from"
    - "enqueue"
    - "dequeue"
    
    # Dynamic programming
    - "dp solution"
    - "dp approach"
    - "dynamic programming"
    - "memoization"
    - "tabulation"
    - "knapsack problem"
    - "longest common subsequence"
    - "longest increasing subsequence"
    - "edit distance"
    - "coin change"
    
    # Techniques
    - "two pointer approach"
    - "two pointers approach"
    - "sliding window approach"
    - "sliding window for"
    - "backtracking approach"
    - "backtracking for"
    - "greedy approach"
    - "greedy algorithm"
    - "divide and conquer approach"
    - "recursion for"
    - "recursion to"
    - "recursive solution"
    - "recursive approach"
    - "iterative solution"
    - "iterative approach"
    
    # Tree operations
    - "binary tree implementation"
    - "binary tree insertion"
    - "binary tree deletion"
    - "binary tree traversal"
    - "binary search tree implementation"
    - "bst implementation"
    - "avl tree implementation"
    - "red black tree implementation"
    - "heap implementation"
    - "trie implementation"
    - "segment tree implementation"
    - "tree traversal code"
    - "tree insertion code"
    - "tree deletion code"
    - "tree search code"
    
    # Graph operations
    - "graph traversal code"
    - "graph traversal implementation"
    - "graph algorithm implementation"
    - "directed graph implementation"
    - "undirected graph implementation"
    - "weighted graph implementation"
    - "adjacency matrix implementation"
    - "adjacency list implementation"
    
    # Common problems
    - "two sum problem"
    - "two sum solution"
    - "three sum problem"
    - "three sum solution"
    - "subarray problem"
    - "subset problem"
    - "permutation problem"
    - "combination problem"
    - "palindrome problem"
    - "anagram problem"
    - "reverse implementation"
    - "rotate implementation"
    - "fibonacci implementation"
    - "fibonacci code"
    - "factorial implementation"
    - "factorial code"
    
    # Request patterns
    - "approach for"
    - "approach to"
    - "solution for"
    - "solution to"
    - "algorithm for"
    - "algorithm to"
    - "code for"
    - "code to"
    - "function for"
    - "function to"
    - "method for"
    - "method to"
  
  # Programming languages (context indicators)
  programming_languages:
    - "python"
    - "java"
    - "javascript"
    - "typescript"
    - "c++"
    - "cpp"
    - "c#"
    - "csharp"
    - "ruby"
    - "go"
    - "golang"
    - "rust"
    - "swift"
    - "kotlin"
    - "scala"
    - "php"
    - "perl"
    - "r"
    - "matlab"
    - "sql"
    - "html"
    - "css"
    - "bash"
    - "shell"
    - "powershell"
  
  # Code structure terms (context indicators)
  code_structures:
    # Basic data structures
    - "function"
    - "method"
    - "class"
    - "object"
    - "variable"
    - "array"
    - "list"
    - "vector"
    - "dictionary"
    - "map"
    - "hashmap"
    - "hashtable"
    - "hash table"
    - "set"
    - "hashset"
    - "tuple"
    - "pair"
    
    # Trees
    - "tree"
    - "binary tree"
    - "binary search tree"
    - "bst"
    - "avl tree"
    - "red black tree"
    - "b-tree"
    - "b+ tree"
    - "trie"
    - "prefix tree"
    - "suffix tree"
    - "segment tree"
    - "fenwick tree"
    - "binary indexed tree"
    - "heap"
    - "min heap"
    - "max heap"
    - "priority queue"
    
    # Graphs
    - "graph"
    - "directed graph"
    - "undirected graph"
    - "weighted graph"
    - "unweighted graph"
    - "dag"
    - "directed acyclic graph"
    - "adjacency matrix"
    - "adjacency list"
    - "edge list"
    
    # Linear data structures
    - "linked list"
    - "singly linked list"
    - "doubly linked list"
    - "circular linked list"
    - "stack"
    - "queue"
    - "deque"
    - "circular queue"
    - "circular buffer"
    
    # Advanced structures
    - "disjoint set"
    - "union find"
    - "bloom filter"
    - "lru cache"
    - "trie"
    
    # Traversals
    - "traversal"
    - "preorder"
    - "pre-order"
    - "inorder"
    - "in-order"
    - "postorder"
    - "post-order"
    - "level order"
    - "level-order"
    - "breadth first"
    - "depth first"
    - "bfs"
    - "dfs"
    
    # Algorithms
    - "algorithm"
    - "sorting"
    - "searching"
    - "merge sort"
    - "quick sort"
    - "heap sort"
    - "bubble sort"
    - "insertion sort"
    - "selection sort"
    - "counting sort"
    - "radix sort"
    - "bucket sort"
    - "binary search"
    - "linear search"
    - "ternary search"
    - "exponential search"
    
    # Graph algorithms
    - "dijkstra"
    - "bellman ford"
    - "floyd warshall"
    - "a star"
    - "a*"
    - "kruskal"
    - "prim"
    - "topological sort"
    - "strongly connected components"
    - "tarjan"
    - "kosaraju"
    - "shortest path"
    - "longest path"
    - "minimum spanning tree"
    - "mst"
    
    # Dynamic programming
    - "dynamic programming"
    - "dp"
    - "memoization"
    - "tabulation"
    - "knapsack"
    - "longest common subsequence"
    - "lcs"
    - "longest increasing subsequence"
    - "lis"
    - "edit distance"
    - "coin change"
    - "matrix chain multiplication"
    
    # Techniques
    - "recursion"
    - "recursive"
    - "iteration"
    - "iterative"
    - "backtracking"
    - "greedy"
    - "divide and conquer"
    - "two pointer"
    - "two pointers"
    - "sliding window"
    - "fast and slow pointer"
    - "tortoise and hare"
    - "kadane"
    - "kadane's algorithm"
    
    # String algorithms
    - "substring"
    - "subsequence"
    - "palindrome"
    - "anagram"
    - "pattern matching"
    - "kmp"
    - "knuth morris pratt"
    - "rabin karp"
    - "z algorithm"
    - "manacher"
    
    # Tree operations
    - "insertion"
    - "deletion"
    - "search"
    - "balancing"
    - "rotation"
    - "left rotation"
    - "right rotation"
    
    # Bit manipulation
    - "bit manipulation"
    - "bitwise"
    - "xor"
    - "and"
    - "or"
    - "bit mask"
    - "bit shift"
    
    # System design & API
    - "api"
    - "rest api"
    - "graphql"
    - "endpoint"
    - "route"
    - "handler"
    - "controller"
    - "service"
    - "middleware"
    - "server"
    - "client"
    - "database"
    - "query"
    - "sql query"
    - "nosql"
    
    # Code elements
    - "loop"
    - "for loop"
    - "while loop"
    - "if statement"
    - "condition"
    - "conditional"
    - "switch case"
    - "try catch"
    - "exception handling"
    - "module"
    - "package"
    - "library"
    - "framework"
    - "component"
    - "interface"
    - "abstract class"
    - "inheritance"
    - "polymorphism"
    - "encapsulation"
    
    # Common problems
    - "two sum"
    - "three sum"
    - "four sum"
    - "n sum"
    - "subarray"
    - "subset"
    - "permutation"
    - "combination"
    - "fibonacci"
    - "factorial"
    - "prime"
    - "gcd"
    - "lcm"
    - "power"
    - "reverse"
    - "rotate"
    - "matrix"
    - "2d array"
    - "grid"
    - "queue"
    - "database"
    - "query"
    - "server"
    - "client"
    - "rest"
    - "graphql"
  
  # NON-CODING indicators (questions that don't require code)
  non_coding_indicators:
    - "what is"
    - "what are"
    - "explain"
    - "describe"
    - "tell me about"
    - "how does"
    - "how do"
    - "why is"
    - "why does"
    - "when should"
    - "difference between"
    - "compare"
    - "versus"
    - "vs"
    - "define"
    - "definition"
    - "meaning of"
    - "concept of"
    - "theory"
    - "principle"
    - "best practice"
    - "advantage"
    - "disadvantage"
    - "pros and cons"
    - "is it better"
    - "should i use"
    - "which is better"

# Pipeline Settings
pipeline:
  max_queue_size: 10           # Maximum pending audio chunks
  processing_timeout: 5.0      # Timeout for processing single chunk
  enable_logging: true         # Log all transcriptions and classifications
  log_file: "transcription_log.jsonl"

# Performance Targets (for monitoring)
performance:
  target_latency_ms: 500       # Target end-to-end latency
  max_latency_ms: 700          # Maximum acceptable latency
  target_accuracy: 0.98        # Target classification accuracy
  max_false_positive_rate: 0.01

# Output Settings
output:
  show_confidence: true        # Show confidence score
  show_latency: true           # Show processing latency
  colorize: true               # Use colored terminal output
  json_output: false           # Output as JSON instead of formatted text
